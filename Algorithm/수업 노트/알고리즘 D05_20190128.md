# 알고리즘 D05_20190128

> 문자열 / 패턴매칭 / 문자열 암호화 / 문자열 압축 / 실습1,2



## 문자열(string)

- <u>문자의 표현</u>
  - ASCII (American Standard Code for Information Interchange) : 문자 인코딩 표준
  - 7bit 인코딩 -128문자를 표현, 95개의 출력 가능한 문자 + 33개의 출력 불가능한 제어문자
    - bit (0/1) : 정보의 최소 단위
    - Byte (8bit) : 영문자 하나의 단위 / 7bit + 1 Panity bit
  - 확장아스키 : panity bit 안써서 추가로 128개 > 지금은 안씀
  - 유니코드 : 다국어 처리를 위한 표준
  - endian (?)



- <u>문자열 뒤집기</u>

  - 자기 문자열에서 뒤집는 방법
  - 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법

  ```python
  # C스타일로 reverse
  def my_strrev(ary):
      str = list(ary)
      for i in range(len(str)//2):
          t = ary[i]
          str[i] = str[len(str)-1-i]
          str[len(str)-1-i] = t
      ary = "".join(str)
      return ary
  
  ary = "abcde"
  ary = my_strrev(ary)
  print(ary)
  
  # 파이썬스타일로 reverse
  s = "Reverse this strings"
  s = s[::-1]
  print(s)
  ```

  

- <u>문자열 비교</u>

  - c - strcmp() 함수 / Java - equals() 메소드 / python - ==, is연산자

  ```python
  # python으로 string compare 함수 구현하기
  def strcmp(str1, str2):
      i = 0
      # str 길이 다르면 일단 False!
      if len(str1) != len(str2):
          return False
      else:
          while i < len(str1) and i < len(str2):
              if str1[i] != str2[i]:
                  return False
              i += 1
      return True
  
  a = 'abc'
  b = 'abc'
  print(strcmp(a, b))   # True
  print(a == b)         # True
  ```



- <u>문자열 숫자를 정수로 변환하기</u> (atoi = array to integer)

  - c - atoi(), itoa() / java - parse메소드 / python - int() float() str() repr()

  ```python
  # python으로 atoi() 구현하기
  def atoi(string):
      value = 0
      i = 0
      while (i < len(string)):
          c = string[i]
          # 문자끼리 비교 : python-유니코드넘버 / c-ascii
          if c >= '0' and c <= '9':
              # ord : ascii로 변환 / ord('0') == 48
              # c = 2 일때 ord(c) == 50 > 50-48 = 2
              digit = ord(c) - ord('0')
          else:
              break
          # * 10 해서 1의 자리에 계속 추가
          value = (value * 10) + digit
          i += 1
      return value
  
  a = '123'
  print(type(a))   # str
  b = atoi(a)
  print(type(b))   # int
  c = int(a)
  print(type(c))   # int
  ```



- <u>문자열 교체하기</u>

  ```python
  str1 = 'abc 1, 2 ABC'
  print(str1)
  str1 = str1.replace('1, 2', 'one, two')
  print(str1)  # abc one, two ABC
  ```

  

- <u>integer to array</u>

  ```python
  # 내 코드 : 망함!
  def itoa(value):
      list = []
      while value > 0:
          list.append(value % 10)
          value //= 10
      return ''.join(list[::-1])
  
  print(itoa(123))
  ```

  ```python
  # 강사님 코드
  def itoa(x):
      str = list()
      y = 0
      while True:
          y = x % 10
          str.append(chr(y + ord('0')))
          x //= 10
          if x == 0:
              break
  
      str.reverse()
      str = ''.join(str)
      return str
  
  x = 123
  print(x, type(x))        # 123 <class 'int'>
  str1 = itoa(x)
  print(str1, type(str1))  # 123 <class 'str'>
  ```

  

## 패턴 매칭 find()



- 고지식한 패턴 검색 알고리즘 (Brute Force)

  - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식

  ```python
  # 슬라이드에 있는 방식
  p = 'is'
  t = 'This is a book~!'
  M = len(p)
  N = len(t)
  
  def BruteForce(p, t):
      i = 0
      j = 0
      while j < M and i < N:
          if t[i] != p[j]:
              i = i - j
              j = -1
          i = i + 1
          j = j + 1
      if j == M:
          return i - M
      else:
          return -1
  
  print(BruteForce(p, t))
  ```

  ```python
  # 추가 for문 활용
  파일에서 보고 추가
  ```

  ```python
  # 추가 while 문 활용
  ```

  

- KMP알고리즘(p.136)
- 보이어-무어 알고리즘(p.139)

- 카프-라빈 알고리즘 (교재 A반_SW문제해결응용_2 p.31 참고)
  - 해쉬값을 찾아서 비교
  - 찾고자하느 문자열에서 한 글자씩 이동하며 패턴 길이만큼 읽어서 해쉬값을 계산하는 게 아니라
  - 새로 추가되는 문자와 그전에 읽었던 값을 이용하여 해쉬값을 구함
  - ex) 6843 > 8432 : 6 버림 ~ 843*10 ~ + 2추가
  - 패턴이 문자열이며 길어지면 길이를 일정 자리수로 맞추기 위해 mod연산을 취해 준다
  - 따라서 해쉬 값이 일치하더라도 실제 패턴이 일치하지 않을 수 있기 때문에 해쉬 값이 일치하면 문자열 일치를 검사해야 한다. (이를 해쉬 충돌이라고 함)



- bit 열의 암호화

  - ```python
    def Bbit_print(a):
        for i in range(7, -1, -1):
            if a & (1<<i):
                print(1, end='')
            else:
                print(0, end='')
        print()
    
    a = 0x86
    key = 0xAA
    print("a      ==>", end=' ')
    Bbit_print(a)
    
    print("a^=key ==>", end=' ')
    a ^= key
    Bbit_print(a)
    
    print("a^=key ==>", end=' ')
    a ^= key
    Bbit_print(a)
    ```



- 문자열 압축
  - Run-length encoding 알고리즘







