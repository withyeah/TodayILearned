# 알고리즘 Intro 

### 20190114 월요일 

김한욱 교수님 / hanoogi@naver.com / 



## A. Introduction

### 1. 삼성 SW 시험

- `Expert` : 다 맞아도 2% 정도만 붙여줌
- `Pro`: 함수이름과 매개변수만 알려주고 함수 구현, 문제 (코딩량 어마어마, 코딩 구현 많이 해 본 사람만 가능)
- `AD` : 대부분 완전검색(재귀), 가ㅏㅏㅏ끔 DP(동적계획법)
- `IM` : 배열 + 다중 for문 (2~3중)



### 2. 참고사이트

- swexpertacademy.com

  > A형 - IM~AD
  >
  > B형 - AD~Pro
  >
  > C형 - Pro~Expert



### 3. C언어의 역사 (갑자기?

> `ALGOR` - `B` - `C` (데니스 리치) - `Java` /Oracle - JRE, JVM
>
> ​                      |                        |- `C++` (객체지향) 
>
> ​                      |                        |-`C#` (Java + C++) /MS -CLR
>
> UNIX 운영체제를 만들기 위해 C를 만듬
>
> - `android` : Java 바탕
> - `iOS` : objective-C 바탕



---





## B. 알고리즘

### 1. 알고리즘

> .sort 메소드 쓰면 되는데 알고리즘 왜하냐 >> 그게 어떻게 동작하는지 알기 위해

> `알고리즘` : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.
>
> ​		  주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함.
>
> > > `어떠한 문제를 해결하기 위한 절차`
>
> 알고리즘 설계할 때는 일단 종이에 손으로 푸는 게 좋다 > 그 후 코딩



> <u>컴퓨터 분야에서 알고리즘을 표현하는 방법 2가지</u>
>
> - 수도코드
> - 순서도



>  **<u>좋은 알고리즘</u>** (p.7)
>
> - 정확성 : 얼마나 정확하게 동작하는가
> - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
> - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
> - 단순성 : 얼마나 단순한가
> - 최적성 : 더 이상 개선할 여지없이 최적화되었는가

> 알고리즘 성능 분석 필요
>
> > ##### **<u>시간 복잡도 (Time Complexity) 표기법</u>** > `빅-오(O) 표기법`
> >
> > - O( 3n + 2 ) = O( n )
> > - O( 2n******2 + 10n + 100 ) = O( n******2 )
> > - O( 4 ) = O ( 1 )
> >
> > > ex) for 문 2중으로 n 번 명령? > O( n**2 )
>
> > <u>p.11 다양한 시간 복잡도의 비교</u>
> >
> > > **`Polynomial`** 현실적 계산 가능
> > >
> > > O( log n ) - 이진 탐색
> > >
> > > O( n ) - 순차 탐색
> > >
> > > O( n log n ) - Quick, Merge, heap
> > >
> > > O( n**2 ) - 선택 Bubble, 삽입
> > >
> > > O( n**3 ) - 모든쌍 최단 경로 (프로이드)
> > >
> > > ---
> > >
> > > **`Nondeterministic Polynomial`** 현실적 계산 어려움 (n이 커지면)
> > >
> > > O( 2**n ) - 부분집합
> > >
> > > O( n! ) - TSP
> >
> > 보통 1초에 10억개 연산 O( n )



### 2. 배열

> **`배열`** : 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
>
> > 배열을 사용하면 하나의 선언을 통해 둘 이상의 변수 선언 가능
> >
> > > 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있음



> **<u>1차원 배열</u>**
>
> 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
>
> > 우리는 C 스타일로 배열 쓸 것임



> <u>연습문제 1</u> `Gravity` ( p. 16 ) > IM레벨
>
> > 2중 for문 + 리스트

> <u>연습문제 2</u> `Baby-gin Game` ( p.19 )
>
> > greedy하게 푸는 방법은 다양함 > 위험 (될 수도 안 될 수도)
> >
> > 완전검색하면 정답은 무조건 맞추게 돼있다.
> >
> > 완전검색 - 6! 가지수를 전부 검증



> **`완전검색`** : 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
>
> > Brute-force / generate_and_test 기법