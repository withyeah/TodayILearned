# Javascript_02_20190501



## A. hoisting

> 변수와 함수를 위한 메모리 공간을 확보하는 과정

#### 배경

> > var : 함수 스코프 ()
> >
> > let/const : 블록 스코프 {}
>
> ```javascript
> // let 블록스코프 예제
> {
>     let x = 'lucio'
>     console.log(x) // 루시우
>     {
>         let x = 'bastion'
>         console.log(x) // 바스티온 
>     }
>     console.log(x) // 루시우
> }
> // console.log(x) // ReferenceError (선언된 적 없음)
> console.log(typeof x) // undefined
> ```
>
> ```javascript
> // 전역변수의 오염
> {
>     var x = 'lucio'
>     console.log(x) // 루시우
>     {
>         var x = 'bastion'
>         console.log(x) // 바스티온 
>     }
>     console.log(x) // 바스티온
> }
> ```
>
> - var VS. let
>
>   var 로 선언하면 현재 스코프(유효범위) 안이라면 어디서든 사용할 수 있으며, 심지어 선언하기도 전에 사용할 수 있다.
>
>   let  으로 선언하면 그 변수는 선언하기 전에는 존재하지 않는다.
>
> - 선언되지 않은 변수(에러 뿜) !== undefined 변수(에러 X, 값 자체가 undefined)
>
>   - ```javascript
>     x 
>     let x = 1 
>     // ReferenceError
>     
>     y 
>     var y = 1
>     y 
>     // 1
>     ```
>
>     변수를 선언하지도 않았는데 그 변수에 접근할 수 있다는 특이한 현상이 발생
>
>     ```javascript
>     // JS가 이해한 코드
>     var y 
>     y       // undefined
>     y = 1   // 1
>     y       // 1
>     ```



#### 예제

```javascript
if (x !== 1) {
    console.log(y)	// undefined	
    var y = 3
    if (y === 3) {
        var x = 1
    }
    console.log(y)	// 3
}
if (x === 1) {
    console.log(y)	// 3
}
```

> 위 코드를 돌리면
>
> ```javascript
> var y
> var x
> if (x !== 1) {
>     console.log(y)
>     y = 3
>     if (y === 3) {
>         x = 1
>     }
>     console.log(y)
> }
> if (x === 1) {
>     console.log(y)
> }
> ```
>
> 위 처럼 실행된다



#### 예제 2

> ```javascript
> // var 로 변수를 선언하면 JS는 같은 변수를 여러번 정의하더라도 무시한다
> var x = 1
> if (x === 1) {
>     var x = 2
>     console.log(x)  // 2
> }
> console.log(x)      // 2
> ```
>
> 위 코드는 실제로 아래처럼 실행된다
>
> ```javascript
> var x
> x = 1
> 
> if (x ===1) {
>     x = 2
>     console.log(x)
> }
> console.log(x)
> ```



#### function hoisting

> ```javascript
> // function hoisting
> // ssafy 함수가 선언되기 전에 ssafy() 로 호출된 형태
> ssafy()
> function ssafy() {
>     console.log('hoisting!!')
> }
> // hoisting!!
> ```
>
> **그러나** 변수에 할당된 함수는 호이스팅 되지 않는다
>
> ```javascript
> ssafy()
> let ssafy = function () {
>     console.log('hoisting!!')
> }
> // ReferenceError
> ```
>
> var ssafy 로 선언해도 똑같이 호이스팅 되지 않음



## B. callback

콜백 함수 : 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수



> 일급객체의 3가지 조건
>
> 1. 변수에 담을 수 있어야 한다.
> 2. 인자로 전달할 수 있다.
> 3. 반환 값(return value)으로 전달 할 수 있다.
>
> ```javascript
> // 일급 객체 3가지 조건
> const fco = function () {   // 1] 변수 fco 에 함수가 저장됨
>     return n => n + 1       // 3] return value가 익명 함수
> }
> console.log(fco)            // 2] fco가 console.log() 함수의 인자로 전달됨 
> ```
>
> ```javascript
> // 도전 num_101 에 101 을 담아야 한다.
> const num_101 = fco()(100)
> ```



#### 예제

```javascript
// setTimeout(callback, 5000)
setTimeout(function () {
    console.log('3초 후 출력된다.')
}, 3000)
```





## C. 동기/비동기

콜백 함수는 주로 비동기 처리 모델에서 사용

동기(직렬) / 비동기(병렬)

중간에 로드가 오래걸리는 함수

최근엔 비동기

브라우저는 스레드가 1개 : 싱글스레드 (탭마다 1개의 스레드, 멀티스레드는 아님)



### blocking (동기) / non_blocking (비동기)

Python vs. JS

> ```python
> from time import sleep
> 
> def sleep_3s():
>     sleep(3)
>     print('Wake up!')
> 
> print('start sleeping')
> sleep_3s()
> print('end of program')
> ```
>
> > start sleeping > 3초 sleep (하는 동안 **block**) > end of program
>
> ```javascript
> const nothing = () => {}
> 
> console.log('start sleeping')
> setTimeout(nothing, 3000) // non-block : callback stack
> console.log('end of program')
> ```
>
> > - start sleeping > end of program
> >
> > - 3초 timeout
> >
> > ```javascript
> > // python code 처럼 동작하게 하려면
> > const logEnd = () => {
> >     console.log('end of program')
> > }
> > console.log('start sleeping')
> > setTimeout(logEnd, 3000)
> > ```



#### non-blocking 

해당 함수의 시작 이후 종료될 때 까지 기다리지 않고 바로 다음 줄의 코드를 실행하는 것을 의미, 코드의 실행을 막지 않는다



#### callback stack

> ```javascript
> function first() {
>     console.log('first')
> }
> function second() {
>     console.log('second')
> }
> function third() {
>     console.log('third')
> }
> first()
> setTimeout(second, 0)
> third()
> ```
>
> ```
> first
> third
> second
> ```
>
> setTimeout은 시간이 0초 이지만 어쨌든 callback stack에 한 번 갔다옴.
>
> callback queue에 들어가있다가 call stack이 비면 이벤트루프가 어! 비었네! 하고 대기열에 있던 timeout을 콜스택에 쌓아줌. third는 동시에 log 찍히기 때문에 second 가 마지막으로 찍힌다.
>
> #### 이벤트 루프
>
> > 시간의 흐름에 따라 코드의 수행을 처리, 그 때마다 JS엔진을 작동시킴
>
> ![event loop](https://cdn-images-1.medium.com/max/1600/1*TozSrkk92l8ho6d8JxqF_w.gif)
>
> 참고) <http://latentflip.com/loupe/?code=ZnVuY3Rpb24gZmlyc3QoKSB7DQogICAgY29uc29sZS5sb2coJ2ZpcnN0JykNCn0NCmZ1bmN0aW9uIHNlY29uZCgpIHsNCiAgICBjb25zb2xlLmxvZygnc2Vjb25kJykNCn0NCmZ1bmN0aW9uIHRoaXJkKCkgew0KICAgIGNvbnNvbGUubG9nKCd0aGlyZCcpDQp9DQpmaXJzdCgpDQpzZXRUaW1lb3V0KHNlY29uZCwgMzAwMCkNCnRoaXJkKCk%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D>

실습문제

>```javascript
>// func1() 를 호출했을 때
>// 아래와 같이 콘솔에 출력
>
>// func1
>// func3
>// func2
>
>// 내 답
>function func3() {
>    console.log('func3')
>}
>function func2() {
>    func3()
>    console.log('func2')
>}
>function func1() {
>    console.log('func1')
>    setTimeout(func2, 0)
>}
>
>func1()
>
>// 강사님 답
>function func1() {
>    console.log('func1')
>    func2()
>}
>function func2() {
>    setTimeout(() => console.log('func2'), 0)
>    func3()
>}
>function func3() {
>    console.log('func3')
>}
>
>func1()
>```



#### callback_practice

 1. 기본

    ```javascript
    // 배열로 이루어진 숫자들을 모두 더하는 함수
    var numbers = [1, 2, 3, 4, 5,]
    const numbersAddEach = numbers => {
        let sum = 0
        for (const number of numbers) {
            sum += number
        }
        return sum
    }
    console.log(numbersAddEach(numbers))
    
    // 배열로 이루어진 숫자들을 모두 빼는 함수
    const numbersSubEach = numbers => {
        let ans = 0
        for (const number of numbers) {
            ans -= number
        }
        return ans
    }
    console.log(numbersSubEach(numbers))
    
    // 배열로 이루어진 숫자들을 모두 곱하는 함수
    const numbersMulEach = numbers => {
        let ans = 1
        for (const number of numbers) {
            ans *= number
        }
        return ans
    }
    console.log(numbersMulEach(numbers))
    ```

2. 조각을 내보자!

   ```javascript
   // 조각을 내보자!
   // 1] 숫자로 이루어진 배열의 요소들을 각각 [??] 한다. [??] 안에 쓸 말은 알아서 해라.
   const numbersEach = (numbers, callback) => {
       let acc
       for (const number of numbers) {
           acc = callback(number, acc) // [??] 한다. == callback
       }
       return acc
   }
   
   // 2-1] 더한다
   const addEach = (number, acc = 0) => {
       return acc + number
   }
   console.log(numbersEach(numbers, addEach))
   
   // 2-2] 뺀다
   const subEach = (number, acc = 0) => {
       return acc - number
   }
   console.log(numbersEach(numbers, subEach))
   
   // 2-3] 곱한다
   const mulEach = (number, acc = 1) => {
       return acc * number
   }
   console.log(numbersEach(numbers, mulEach))
   ```

3. 익명함수로 바꿔보자!

   ```javascript
   // 익명함수로 바꿔보자!
   // numbersEach 이후의 제어들을 우리가 함수 정의 없이 매번 자유롭게 하려면?
   const NUMBERS = [1, 2, 3, 4, 5,]
   const numbersEach = (numbers, callback) => {
       let acc
       for (let i = 0; i < numbers.length; i++) {
           number = numbers[i]
           acc = callback(number, acc)
       }
       return acc
   }
   numbersEach(NUMBERS, (number, acc = 0) => acc + number)
   numbersEach(NUMBERS, (number, acc = 0) => acc - number)
   numbersEach(NUMBERS, (number, acc = 1) => acc * number)
   ```

   

> > js 파일 정리 내용 정리하기













## E. EventListener

무엇을 언제 어떻게 한다.

ex) 버튼을 클릭하면(이벤트) 뿅한다(리턴)















